<?php

class Queue
{
    private int $rear = 0,  //$rear - индекс элемента в конце очереди
                $front = 0; //$front - индекс элемента в начале очереди

    private array $items; //хранит элементы, добавляемые в очередь

    /* элементы вставляются на позиции с большим индексом (В КОНЕЦ ОЧЕРЕДИ - $rear), чем предыдущие ($this->rear++)
     * - счетчик индексов ($rear) увеличивается на 1 ПОСЛЕ того, как элмент был добавлен (из-за постинкремента),
    **/
    public function insert($item)
    {
        $this->items[ $this->rear++ ] = $item;
    }

    /* элементы извлекаются с позиции с большим индексом (ИЗ НАЧАЛА ОЧЕРЕДИ - $front), чем предыдущие ($this->front++)
     * - счетчик индексов ($front) увеличивается на 1 ПОСЛЕ того, как элемент был извлечен (из-за постинкремента).
     * Таким образом, элемент не удаляется из очереди, а лишь маркируется как удаленный, с помощью счетчика индексов,
     * который указывает на начало очереди - $front
    **/
    public function remove() :mixed
    {
        if( $this->isEmpty() )
            throw new Exception('Nothing to delete. The queue is empty');

        return $this->items[ $this->front++ ];
    }

    /* возвращаем первый элемент из начала очереди без его удаления
    **/
    public function peek() :mixed
    {
        return $this->items[ $this->front ];
    }

    /* Поскольку мы храним индекс первого и последнего элемента очереди
     * - то размер очереди (кол-во элементов) - это разница между индексами
     * последнего и первого элемента очереди
    **/
    public function size() :int
    {
        return $this->rear - $this->front;
    }

    /* Пустая очередь - очередь, РАЗМЕР (кол-во элементов) которой равен НУЛЮ.
    **/
    public function isEmpty() :bool
    {
        return $this->size() === 0;
    }
}

//$q = new Queue();

//$q->insert( 10 );  //1
//$q->insert( 'rtyry' );  //2
//$q->insert( [5, 7, 'y'] ); //3

//$q->remove( );

//var_dump( $q->isEmpty() );