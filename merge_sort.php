<?php

//склеиваем УЖЕ ОТСОРТИРОВАННЫЕ массивы А и В в массив С
function merge(array $arr_A, array $arr_B)
{
    $arr_C = [];

    $size_A = count($arr_A);     $size_B = count($arr_B);

    $a_index = 0; $b_index = 0;   //счетчики индексов (указатели текущего элемента) для каждого из массивов

    while($a_index < $size_A && $b_index < $size_B) //Случай 1: ни А, ни В не пустые - обходим все элементы
    {
        if($arr_A[ $a_index ] < $arr_B[ $b_index ]) //если текущий ($a_index) элемент массива А меньше текущего ($b_index) элемента массива В
            $arr_C[ ] = $arr_A[ $a_index++ ];    //записываем его (НАИМЕНЬШИЙ элемент - он должен быть первым) в конечный массив
            //одновременно переходим к следующему элементу массива А ($a_index++)
        else    //но как только элемент массива А стал больше
            $arr_C[ ] = $arr_B[ $b_index++ ]; //то записываем элемент массива В (так как он НАИМЕНЬШИЙ из двух)
            //одновременно переходим к следующему элементу массива B ($b_index++)
    }

    while($a_index < $size_A) //Случай 2: обход массива А еще не закончен, но массив В уже обошли
    {
        $arr_C[ ] = $arr_A[ $a_index++ ];   //тогда добавим оставшиеся элементы массива А в конец массива С (они ведь уже отсортированы)
        //одновременно переходим к следующему элементу массива А ($a_index++)
    }

    while($b_index < $size_B) //Случай 3: обход массива B еще не закончен, но массив A уже обошли
    {
        $arr_C[ ] = $arr_B[ $b_index++ ];   //тогда добавим оставшиеся элементы массива B в конец массива С (они ведь уже отсортированы)
        //одновременно переходим к следующему элементу массива B ($b_index++)
    }

    return $arr_C;
}

function merge_sort(array $arr)
{
    $lower_bound = 0;               //границы доступных индексов в массиве
    $upper_bound = count($arr) - 1;

    if ($lower_bound == $upper_bound)   //если в массиве остался один элемент (BASE CASE) - сортировка не требуется
        return [ $arr[$lower_bound] ];  //возвращаем элемент, завернутый в массив, потому что при сортировке будем склеивать меньшие массивы в большие

    $mid = ($upper_bound + $lower_bound)/2;     //найдем средний индекс (который делит массив пополам)

    //обе половины - и левую, и правую - нужно отсортировать (в отличие от предыдущих алгоритмов, где нужна была только одна половина)
    $left_side = array_slice($arr, 0, $mid + 1);  //отрезаем от массива левую половину
    $right_side = array_slice($arr, $mid + 1);  //отрезаем от массива правую половину

    //рекурсия - сортируем все меньшие и меньшие массивы, пока не дойдем др одного элемента (чит. BASE CASE выше)
    $left_sorted = merge_sort($left_side);    //сортируем левую половину массива
    $right_sorted = merge_sort($right_side);    //сортируем правую половину массива

    //склеить отсортированные половины обратно в исходный массив (за счет рекурсии эта функция
    //склеивает все большие и большие половины, пока не образует исходный массив (фактически, эти половины каждый раз пересортировываются)
    return merge($left_sorted, $right_sorted);
}


$arr = [1, 4, 8, 5, 3, 11, 1122, 100, 9];
var_dump( merge_sort($arr) );

//var_dump( $arr );